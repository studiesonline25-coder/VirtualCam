package com.virtucam.hooks

import android.app.AndroidAppHelper
import android.graphics.BitmapFactory
import android.graphics.SurfaceTexture
import android.net.Uri
import android.opengl.GLES20
import android.opengl.GLUtils
import android.opengl.Matrix
import android.view.Surface
import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XposedBridge
import de.robv.android.xposed.XposedHelpers
import de.robv.android.xposed.callbacks.XC_LoadPackage
import com.virtucam.ModuleMain
import com.virtucam.media.StreamPlayer
import com.virtucam.media.VideoPlayer
import com.virtucam.opengl.EglCore
import com.virtucam.opengl.TextureRenderer

/**
 * Camera2 API Hooks - Surface Hijacking implementation
 * 
 * Intercepts camera session creation and substitutes the requested output Surface
 * with our own virtual rendering pipeline powered by OpenGL ES and MediaCodec.
 */
object CameraHook {
    
    private var isEnabled = true
    private var isVideo = false
    private var isStream = false
    private var streamUrl: String = ""
    private var targetPackage: String = ""
    
    private val renderThreads = mutableListOf<VirtualRenderThread>()

    /**
     * Initialize all camera hooks
     */
    fun init(lpparam: XC_LoadPackage.LoadPackageParam) {
        targetPackage = lpparam.packageName
        
        loadConfiguration()
        
        hookCameraDevice(lpparam)
        hookCameraDeviceOutputConfigurations(lpparam)
        
        ModuleMain.log("Camera Surface Hijacking hooks set up for $targetPackage")
    }

    /**
     * Poll configuration via ContentProvider
     */
    private fun loadConfiguration() {
        try {
            val context = AndroidAppHelper.currentApplication() ?: return
            val uri = Uri.parse("content://com.virtucam.provider/config")
            val cursor = context.contentResolver.query(uri, null, null, null, null)
            
            cursor?.use {
                if (it.moveToFirst()) {
                    try {
                        isEnabled = it.getInt(0) == 1
                        
                        // Default values for missing columns in older DB versions
                        isVideo = if (it.columnCount > 2) it.getInt(2) == 1 else false
                        isStream = if (it.columnCount > 3) it.getInt(3) == 1 else false
                        streamUrl = if (it.columnCount > 4) it.getString(4) ?: "" else ""
                        
                        ModuleMain.log("Config loaded. Enabled: $isEnabled, IsVideo: $isVideo, IsStream: $isStream")
                    } catch (innerE: Exception) {
                        ModuleMain.log("Error parsing cursor columns: ${innerE.message}")
                    }
                }
            }
        } catch (e: Exception) {
            ModuleMain.log("Failed to load configuration: ${e.message}")
        }
    }

    /**
     * Hooks createCaptureSession(List<Surface>, ...)
     */
    private fun hookCameraDevice(lpparam: XC_LoadPackage.LoadPackageParam) {
        val cameraDeviceImplClass = XposedHelpers.findClassIfExists(
            "android.hardware.camera2.impl.CameraDeviceImpl",
            lpparam.classLoader
        ) ?: return

        XposedBridge.hookAllMethods(
            cameraDeviceImplClass,
            "createCaptureSession",
            object : XC_MethodHook() {
                @Suppress("UNCHECKED_CAST")
                override fun beforeHookedMethod(param: MethodHookParam) {
                    if (!isEnabled) return

                    try {
                        val args = param.args
                        if (args.isEmpty() || args[0] !is List<*>) return

                        val surfacesList = args[0] as List<Surface>
                        if (surfacesList.isNotEmpty()) {
                            ModuleMain.log("Intercepted createCaptureSession (Surface list) - count: ${surfacesList.size}")
                            
                            val newSurfaces = ArrayList<Surface>()
                            val targetSurfaces = ArrayList<Surface>()
                            
                            for (targetSurface in surfacesList) {
                                targetSurfaces.add(targetSurface)
                                
                                val dummySurfaceTexture = SurfaceTexture(10)
                                val dummySurface = Surface(dummySurfaceTexture)
                                newSurfaces.add(dummySurface)
                            }
                            
                            param.args[0] = newSurfaces
                            
                            startRenderThreads(targetSurfaces)
                            obfuscateStackTrace()
                        }
                    } catch (t: Throwable) {
                        ModuleMain.log("Error in createCaptureSession hook: ${t.message}")
                    }
                }
            }
        )
    }

    /**
     * Hooks createCaptureSessionByOutputConfigurations(List<OutputConfiguration>, ...)
     */
    private fun hookCameraDeviceOutputConfigurations(lpparam: XC_LoadPackage.LoadPackageParam) {
        val cameraDeviceImplClass = XposedHelpers.findClassIfExists(
            "android.hardware.camera2.impl.CameraDeviceImpl",
            lpparam.classLoader
        ) ?: return

        XposedBridge.hookAllMethods(
            cameraDeviceImplClass,
            "createCaptureSessionByOutputConfigurations",
            object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam) {
                    if (!isEnabled) return
                    
                    try {
                        val args = param.args
                        if (args.isEmpty() || args[0] !is List<*>) return
                        
                        val configs = args[0] as List<*>
                        if (configs.isNotEmpty()) {
                            ModuleMain.log("Intercepted createCaptureSessionByOutputConfigurations - count: ${configs.size}")
                            
                            val newConfigs = ArrayList<Any>()
                            val targetSurfaces = ArrayList<Surface>()
                            
                            for (config in configs) {
                                if (config == null) continue
                                
                                val getSurfaceMethod = config.javaClass.getMethod("getSurface")
                                val targetSurface = getSurfaceMethod.invoke(config) as? Surface
                                
                                if (targetSurface != null) {
                                    targetSurfaces.add(targetSurface)
                                    
                                    val dummySurfaceTexture = SurfaceTexture(10)
                                    val dummySurface = Surface(dummySurfaceTexture)
                                    
                                    val newConfig = XposedHelpers.newInstance(config.javaClass, dummySurface)
                                    newConfigs.add(newConfig)
                                } else {
                                    newConfigs.add(config)
                                }
                            }
                            
                            param.args[0] = newConfigs
                            
                            startRenderThreads(targetSurfaces)
                            obfuscateStackTrace()
                        }
                    } catch (t: Throwable) {
                        ModuleMain.log("Error in createCaptureSessionByOutputConfigurations hook: ${t.message}")
                    }
                }
            }
        )
        
        // Android 28+ uses SessionConfiguration
        XposedBridge.hookAllMethods(
            cameraDeviceImplClass,
            "createCaptureSession",
            object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam) {
                    if (!isEnabled) return
                    
                    try {
                        val args = param.args
                        if (args.isEmpty()) return
                        
                        val sessionConfig = args[0]
                        if (sessionConfig != null && sessionConfig.javaClass.simpleName == "SessionConfiguration") {
                            val getOutputConfigsMethod = sessionConfig.javaClass.getMethod("getOutputConfigurations")
                            val configs = getOutputConfigsMethod.invoke(sessionConfig) as? List<*>
                            
                            if (!configs.isNullOrEmpty()) {
                                ModuleMain.log("Intercepted SessionConfiguration - count: ${configs.size}")
                                
                                val targetSurfaces = ArrayList<Surface>()
                                
                                for (config in configs) {
                                    if (config == null) continue
                                    val getSurfaceMethod = config.javaClass.getMethod("getSurface")
                                    val targetSurface = getSurfaceMethod.invoke(config) as? Surface
                                    
                                    if (targetSurface != null) {
                                        targetSurfaces.add(targetSurface)
                                    }
                                }
                                
                                startRenderThreads(targetSurfaces)
                                obfuscateStackTrace()
                            }
                        }
                    } catch (t: Throwable) {
                        ModuleMain.log("Error overriding SessionConfiguration: ${t.message}")
                    }
                }
            }
        )
    }

    private fun startRenderThreads(targetSurfaces: List<Surface>) {
        renderThreads.forEach { it.quit() }
        renderThreads.clear()
        
        val context = AndroidAppHelper.currentApplication() ?: return
        
        for (surface in targetSurfaces) {
            val thread = VirtualRenderThread(surface, context, isVideo, isStream, streamUrl).apply {
                start()
            }
            renderThreads.add(thread)
        }
    }
    
    /**
     * Anti-Plugin mechanism: Removes our hooking frames from thread stack trace
     */
    private fun obfuscateStackTrace() {
        // Minimal stack trace scrubber signature
        // Advanced impl involves replacing the thread's StackTraceElement array
    }
}

/**
 * Dedicated thread targeting the hijacked surface via EGL
 */
class VirtualRenderThread(
    private val targetSurface: Surface,
    private val context: android.content.Context,
    private val isVideo: Boolean,
    private val isStream: Boolean,
    private val streamUrl: String
) : Thread("VirtuCam-RenderThread") {
    
    @Volatile
    private var isRunning = true
    
    private var eglCore: EglCore? = null
    private var eglSurface: android.opengl.EGLSurface? = null
    private var textureRenderer: TextureRenderer? = null
    
    private var videoPlayer: VideoPlayer? = null
    private var streamPlayer: StreamPlayer? = null
    
    private var mediaSurfaceTexture: SurfaceTexture? = null
    private var mediaSurface: Surface? = null
    
    override fun run() {
        try {
            eglCore = EglCore()
            eglSurface = eglCore!!.createWindowSurface(targetSurface)
            eglCore!!.makeCurrent(eglSurface!!)
            
            textureRenderer = TextureRenderer(isVideo)
            textureRenderer!!.init()
            
            val uri = Uri.parse("content://com.virtucam.provider/file")
            
            if (isStream) {
                // Live Stream Pipeline (ExoPlayer)
                mediaSurfaceTexture = SurfaceTexture(textureRenderer!!.textureId)
                mediaSurface = Surface(mediaSurfaceTexture)
                
                streamPlayer = StreamPlayer(context, streamUrl, mediaSurface!!) {
                    mediaSurfaceTexture?.updateTexImage()
                    val matrix = FloatArray(16)
                    mediaSurfaceTexture?.getTransformMatrix(matrix)
                    textureRenderer?.draw(matrix, 90) // Simplified Portrait Orientation
                    eglCore?.swapBuffers(eglSurface!!)
                }
                streamPlayer!!.start()
                
                while (isRunning) {
                    sleep(100)
                }
                streamPlayer!!.stop()
                
            } else if (isVideo) {
                // Local Video Pipeline (MediaCodec)
                mediaSurfaceTexture = SurfaceTexture(textureRenderer!!.textureId)
                mediaSurface = Surface(mediaSurfaceTexture)
                
                val pfd = context.contentResolver.openFileDescriptor(uri, "r")
                if (pfd != null) {
                    val fd = pfd.fileDescriptor
                    videoPlayer = VideoPlayer(fd, mediaSurface!!) {
                        mediaSurfaceTexture?.updateTexImage()
                        val matrix = FloatArray(16)
                        mediaSurfaceTexture?.getTransformMatrix(matrix)
                        textureRenderer?.draw(matrix, 90)
                        eglCore?.swapBuffers(eglSurface!!)
                    }
                    videoPlayer!!.start()
                    
                    while (isRunning) {
                        sleep(100)
                    }
                    
                    videoPlayer!!.stop()
                    pfd.close()
                }
            } else {
                // Static Image Mode Pipeline
                val stream = context.contentResolver.openInputStream(uri)
                val bitmap = BitmapFactory.decodeStream(stream)
                stream?.close()
                
                if (bitmap != null) {
                    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureRenderer!!.textureId)
                    GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0)
                    bitmap.recycle()
                    
                    val matrix = FloatArray(16)
                    Matrix.setIdentityM(matrix, 0)
                    
                    while (isRunning) {
                        textureRenderer?.draw(matrix, 90)
                        eglCore?.swapBuffers(eglSurface!!)
                        sleep(33) // ~30 fps simulated heartbeat
                    }
                }
            }
        } catch (t: Throwable) {
            ModuleMain.log("Render thread error: ${t.message}")
        } finally {
            mediaSurface?.release()
            mediaSurfaceTexture?.release()
            textureRenderer?.release()
            if (eglSurface != null && eglCore != null) {
                eglCore!!.releaseSurface(eglSurface!!)
            }
            eglCore?.release()
        }
    }
    
    fun quit() {
        isRunning = false
    }
}
